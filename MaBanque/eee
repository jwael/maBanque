class ClsKafkaListenerEpartnerCustomerFeedbackTest {

    private val handleClsCustomerFeedbackUseCaseApi = mockk<HandleClsCustomerFeedbackUseCaseApi>(relaxed = true)

    private val listener = ClsKafkaListener(
        handleClsCustomerRequestUseCaseApi = mockk(relaxed = true),
        handleClsCustomerFeedbackUseCaseApi = handleClsCustomerFeedbackUseCaseApi,
        handleClsCustomerSendingUseCaseApi = mockk(relaxed = true),
        handleClsContactRequestUseCaseApi = mockk(relaxed = true),
        handleClsContactFeedbackUseCaseApi = mockk(relaxed = true)
    )

    @ParameterizedTest
    @CsvSource(
        "FR, ABC1234567-XYZ9876543, SUCCESS, , SALES",
        "DE, DEF9876543-UVW1234567, ERROR, Message erreur, SUPPORT"
    )
    fun `should invoke customer feedback use case with correct payload`(
        country: String,
        reconciliationId: String,
        status: String,
        errorMessage: String?,
        scope: String?
    ) {
        // GIVEN
        val message = ClsFeedbackCustomerKafkaMessage(
            scope = scope,
            status = status,
            errorMessage = errorMessage
        )

        // WHEN
        listener.acceptClsEpartnerCustomerFeedback(
            countryHeader = country,
            reconciliationIdHeader = reconciliationId,
            clsFeedbackCustomerKafkaMessage = message
        )

        // THEN
        verify(exactly = 1) {
            handleClsCustomerFeedbackUseCaseApi.invoke(
                clsCustomerDataFeedbackPayload = match { payload ->
                    payload.countryCode.value == country &&
                    payload.reconciliationId.print() == reconciliationId &&
                    payload.status == status &&
                    (payload.errorMessage ?: "*") == (errorMessage ?: "*") &&
                    (payload.scope ?: "*") == (scope ?: "*")
                }
            )
        }
    }
}