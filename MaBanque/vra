import org.junit.jupiter.api.DisplayName
import org.junit.jupiter.params.ParameterizedTest
import org.junit.jupiter.params.provider.CsvSource
import org.springframework.mock.web.MockHttpServletRequest
import org.springframework.mock.web.MockHttpServletResponse
import org.springframework.mock.web.MockServletContext
import org.springframework.security.web.DefaultSecurityFilterChain
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders
import kotlin.test.assertEquals

@DisplayName("RestSecurityConfiguration - securityFilterChain() Tests")
class RestSecurityConfigurationTest {

    private val blmAccessDeniedHandler = BlmAccessDeniedHandler()
    private val blmAuthEntryPoint = BLmAuthEntryPoint()
    private val configuration = RestSecurityConfiguration(
        corsAlLowedOrigins = arrayOf("http://localhost"),
        caixaImportClientId = "CAIXA_IMPORT",
        caixaImportClientSecret = "secret",
        bLmAccessDeniedHandler = blmAccessDeniedHandler,
        bLmAuthEntryPoint = blmAuthEntryPoint
    )

    private val chain: DefaultSecurityFilterChain by lazy {
        configuration.securityFilterChain(mockk(relaxed = true))
    }

    @ParameterizedTest(name = "Request {0} expected status {1}")
    @CsvSource(
        "/swagger-ui/index.html,200",
        "/api/v1/customers/caixa/import,401",
        "/api/v1/unknown,401"
    )
    fun `test securityFilterChain access`(requestPath: String, expectedStatus: Int) {
        // Construire la requête HTTP simulée
        val request = MockMvcRequestBuilders.get(requestPath)
            .buildRequest(MockServletContext())
        val response = MockHttpServletResponse()

        // Appliquer le vrai filter chain de Spring Security
        chain.doFilter(request, response)

        // Vérifier le code HTTP attendu
        assertEquals(expectedStatus, response.status)
    }
}