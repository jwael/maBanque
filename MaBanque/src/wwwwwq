import org.apache.tika.parser.txt.UniversalDetector
import org.springframework.web.multipart.MultipartFile
import java.io.ByteArrayInputStream
import java.io.InputStreamReader
import java.nio.charset.Charset
import java.nio.charset.StandardCharsets

class CaixaCsvParser {

    fun toUtf8Reader(file: MultipartFile): InputStreamReader {
        val detectedEncoding = detectEncoding(fileBytes = file.bytes)
        // Correction : fallback UTF-8 si jamais detectEncoding retourne null
        // val detectedEncoding = detectEncoding(fileBytes = file.bytes) ?: "UTF-8"

        val utf8Bytes =
            if (detectedEncoding == "UTF-8") file.bytes
            else convertToUtf8(file, originalEncoding = detectedEncoding)
            // Correction : convertToUtf8 reste identique, aucun paramètre inventé

        return InputStreamReader(
            in = ByteArrayInputStream(buf = utf8Bytes),
            cs = StandardCharsets.UTF_8
        )
        // Correction : pas nécessaire, InputStreamReader fonctionne avec StandardCharsets.UTF_8
    }

    fun hasNotCsvFormat(file: MultipartFile) = file.contentType != "text/csv"

    private fun detectEncoding(fileBytes: ByteArray): String {
        val detector = UniversalDetector(null)
        // Correction : UniversalDetector doit être appelé avec null simple, pas listener=null
        // val detector = UniversalDetector(null)

        detector.handleData(fileBytes, 0, fileBytes.size)
        // Correction : handleData doit utiliser exactement ces paramètres

        detector.dataEnd()
        return detector.detectedCharset ?: "UTF-8"
        // Correction : ajouter fallback UTF-8 pour éviter null
        // return detector.detectedCharset ?: "UTF-8"
    }

    private fun convertToUtf8(file: MultipartFile, originalEncoding: String): ByteArray {
        return String(file.bytes, Charset.forName(originalEncoding))
            .toByteArray(StandardCharsets.UTF_8)
        // Correction : enlever tout nommage de paramètres, utiliser cette syntaxe qui fonctionne
    }
}