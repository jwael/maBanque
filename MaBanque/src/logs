package com.arval.blm.infrastructure.driving.rest.common

import org.mozilla.universalchardet.UniversalDetector
import org.springframework.web.multipart.MultipartFile
import java.io.ByteArrayInputStream
import java.io.InputStreamReader
import java.nio.charset.Charset
import java.nio.charset.StandardCharsets
import org.slf4j.LoggerFactory

object OpenCsvUtils {

    private val logger = LoggerFactory.getLogger(OpenCsvUtils::class.java)

    /**
     * Convertit un fichier MultipartFile en InputStreamReader UTF-8.
     * Log les √©tapes pour comprendre d'o√π vient le probl√®me d'encodage.
     */
    fun toUtf8Reader(file: MultipartFile): InputStreamReader {
        logger.debug("‚û°Ô∏è [toUtf8Reader] D√©marrage de la lecture du fichier: ${file.originalFilename}")
        val fileBytes = file.bytes
        logger.debug("üì¶ Taille du fichier: ${fileBytes.size} octets")

        val detectedEncoding = detectEncoding(fileBytes)
        logger.debug("üîç Encodage d√©tect√©: $detectedEncoding")

        // Convert file bytes to UTF-8 if needed
        val utf8Bytes = if (detectedEncoding.equals("UTF-8", ignoreCase = true)) {
            logger.debug("‚úÖ Fichier d√©j√† en UTF-8, aucune conversion n√©cessaire.")
            fileBytes
        } else {
            logger.debug("üîÅ Conversion du fichier depuis $detectedEncoding vers UTF-8 ...")
            convertToUtf8(file, originalEncoding = detectedEncoding)
        }

        // Affiche un extrait du d√©but du fichier pour v√©rification
        val preview = String(utf8Bytes, StandardCharsets.UTF_8)
            .take(200)
            .replace("\n", "\\n")
            .replace("\r", "\\r")
        logger.debug("üßæ Aper√ßu du contenu (200 premiers caract√®res): $preview")

        // Nettoyage optionnel (BOM ou caract√®res parasites)
        val cleanedBytes = preview.removePrefix("\uFEFF").toByteArray(StandardCharsets.UTF_8)

        logger.debug("üöÄ Cr√©ation de l‚ÄôInputStreamReader en UTF-8.")
        return InputStreamReader(ByteArrayInputStream(cleanedBytes), StandardCharsets.UTF_8)
    }

    /**
     * V√©rifie si le fichier n‚Äôest pas au format CSV.
     */
    fun hasNotCsvFormat(file: MultipartFile): Boolean {
        val notCsv = file.contentType != "text/csv"
        logger.debug("üß© V√©rification du format CSV: contentType='${file.contentType}', r√©sultat=$notCsv")
        return notCsv
    }

    /**
     * D√©tecte l'encodage du fichier avec Mozilla UniversalDetector.
     */
    private fun detectEncoding(fileBytes: ByteArray): String {
        logger.debug("üîé D√©tection de l‚Äôencodage en cours ...")
        val detector = UniversalDetector(null)
        detector.handleData(fileBytes, 0, fileBytes.size)
        detector.dataEnd()
        val detected = detector.detectedCharset ?: "UTF-8"
        logger.debug("üß† Encodage d√©tect√© par UniversalDetector: $detected")
        return detected
    }

    /**
     * Convertit le fichier en UTF-8 si son encodage d‚Äôorigine est diff√©rent.
     */
    private fun convertToUtf8(file: MultipartFile, originalEncoding: String): ByteArray {
        logger.debug("‚öôÔ∏è Conversion en UTF-8 depuis l‚Äôencodage: $originalEncoding")
        return String(file.bytes, Charset.forName(originalEncoding))
            .toByteArray(StandardCharsets.UTF_8)
    }
}