import io.mockk.*
import kotlinx.coroutines.test.runTest
import org.junit.jupiter.api.*
import org.junit.jupiter.api.Nested
import org.junit.jupiter.params.ParameterizedTest
import org.junit.jupiter.params.provider.CsvSource
import java.time.Instant
import java.util.stream.IntStream
import dev.instancio.Instancio

@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class ImportCustomerServiceTest {

    // --- Dependencies (mockées)
    private val recordStepEventRepositorySpi = mockk<RecordStepEventRepositorySpi>(relaxed = true)
    private val crmClsCustomerDataRepositorySpi = mockk<CrmClsCustomerDataRepositorySpi>(relaxed = true)
    private val crmCustomerProviderSpi = mockk<CrmCustomerProviderSpi>(relaxed = true)
    private val batchRepositorySpi = mockk<BatchRepositoryForContactsSpi>(relaxed = true)
    private val clockProvider: ClockProvider = mockk()

    // --- Service à tester
    private lateinit var importCustomerService: ImportCustomersService

    // --- Données communes
    private lateinit var newBatch: LoaderBatch
    private lateinit var personalAccounts: List<CustomerPayload>

    @BeforeEach
    fun setUp() {
        // ClockProvider mocké
        every { clockProvider.now() } returns Instant.parse("2025-10-14T00:00:00Z")

        importCustomerService = ImportCustomerService(
            recordStepEventRepositorySpi = recordStepEventRepositorySpi,
            crmClsCustomerDataRepositorySpi = crmClsCustomerDataRepositorySpi,
            crmCustomerProviderSpi = crmCustomerProviderSpi,
            batchRepositorySpi = batchRepositorySpi,
            logger = mockk(relaxed = true)
        )

        // Batch commun
        newBatch = LoaderBatch(
            id = "AAAAA",
            reference = "BATCH_REF",
            fileName = "customers.csv",
            triggeredBy = "user-001",
            countryCode = "FR",
            status = LoaderBatchStatus.RUNNING,
            startDate = Instant.MIN,
            endDate = Instant.MIN,
            totalContacts = 2,
            type = LoaderBatchType.CONTACTS
        )

        // Liste de comptes à créer
        personalAccounts = IntStream.range(0, 2).mapToObj {
            CustomerPayload(
                rowNumber = it + 1,
                errorMessage = null,
                crmData = Instancio.of(CrmData::class.java)
                    .set(CrmData::salesforceRoleId, null)
                    .set(CrmData::salesforceContactId, null)
                    .set(CrmData::salutation, "Dr.")
                    .set(CrmData::title, "Dr.")
                    .set(CrmData::languageCode, "French")
                    .set(CrmData::sex, "Male")
                    .set(CrmData::contactRole, "Customer")
                    .set(CrmData::homeCountry, "FRANCE")
                    .set(CrmData::workCountry, "FRANCE")
                    .set(CrmData::homeProvince, "Norrland")
                    .set(CrmData::workProvince, "Norrland")
                    .create()
            )
        }.toList()

        // Mocks généraux
        coEvery { crmClsCustomerDataRepositorySpi.save(any()) } answers { firstArg() }
        coEvery { recordStepEventRepositorySpi.save(any()) } answers { firstArg() }
        coEvery { crmCustomerProviderSpi.createCrmCustomer(any()) } returns CrmCustomerResponsePayload(
            crmAccountId = "ACC123",
            crmStatus = RecordStepStatus.OK,
            crmMessage = "Customer created",
            crmRoleId = null
        )
    }

    @Nested
    @DisplayName("apply() - personal accounts scenarios")
    inner class ApplyTests {

        @ParameterizedTest(name = "should process account with country {0}")
        @CsvSource("FR", "IT", "UK")
        fun `apply should process personal accounts successfully`(country: String) = runTest {
            // Given
            val accounts = personalAccounts.map { it.copy(
                crmData = it.crmData.apply {
                    // remplacer le pays dans CrmData
                    this.mainCountry = country
                }
            ) }

            // When
            importCustomerService.apply(newBatch, accounts)

            // Then
            coVerify {
                crmClsCustomerDataRepositorySpi.save(match { it.crmData["salesforceRoleId"] == null })
            }

            coVerify {
                recordStepEventRepositorySpi.save(match {
                    it.batchId == newBatch.id &&
                    it.stepStatus == RecordStepStatus.OK
                })
            }
        }

        @Test
        fun `apply should handle personal account with error message`() = runTest {
            val accountWithError = personalAccounts.first().copy(errorMessage = "Validation error")
            val accounts = listOf(accountWithError)

            importCustomerService.apply(newBatch, accounts)

            coVerify(exactly = 0) { crmClsCustomerDataRepositorySpi.save(any()) }

            coVerify {
                recordStepEventRepositorySpi.save(match {
                    it.batchId == newBatch.id &&
                    it.rowNumber == accountWithError.rowNumber &&
                    it.stepStatus == RecordStepStatus.KO &&
                    it.stepMessage == "Elpersona LAccount errorlessage?"
                })
            }
        }
    }
}